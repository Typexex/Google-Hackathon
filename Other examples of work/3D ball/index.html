<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nebula Core - High Performance 3D Sphere</title>
    <link rel="stylesheet" href="style.css">
    
    <!-- Three.js from CDN -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">Initializing Core...</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-container">
        <h1>NEBULA CORE</h1>
        <div class="controls">
            <div class="control-group">
                <label for="speed-slider">Rotation</label>
                <input type="range" id="speed-slider" min="0" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label for="bloom-toggle">Bloom</label>
                <input type="checkbox" id="bloom-toggle" checked>
            </div>
            <div class="control-group">
                <label>Theme</label>
                <div class="presets">
                    <button class="preset-btn active" data-color="cyan" style="background: #00f2ff;"></button>
                    <button class="preset-btn" data-color="magenta" style="background: #ff0055;"></button>
                    <button class="preset-btn" data-color="gold" style="background: #ffaa00;"></button>
                </div>
            </div>
        </div>
        <div class="hint">Click to Pulse • Drag to Rotate • 'P' for Stats</div>
    </div>

    <!-- Stats Overlay (Hidden by default) -->
    <div id="stats-overlay" style="display: none;"></div>

    <!-- Main Canvas Container -->
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import Stats from 'three/addons/libs/stats.module.js';

        // --- Configuration & State ---
        const CONFIG = {
            rotationSpeed: 0.5,
            baseSpeed: 0.002,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            pulseIntensity: 0,
            pulseDecay: 0.95,
            isHovered: false,
            reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches
        };

        const THEMES = {
            cyan: { color1: new THREE.Color(0x00f2ff), color2: new THREE.Color(0x0044ff) },
            magenta: { color1: new THREE.Color(0xff0055), color2: new THREE.Color(0xaa00ff) },
            gold: { color1: new THREE.Color(0xffaa00), color2: new THREE.Color(0xff4400) }
        };
        let currentTheme = THEMES.cyan;

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Fog for depth blending
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Clamp pixel ratio
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- Performance Stats ---
        const stats = new Stats();
        document.getElementById('stats-overlay').appendChild(stats.dom);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 4;
        controls.maxDistance = 15;

        // --- Lighting (Cinematic Setup) ---
        // 1. Ambient
        const ambientLight = new THREE.AmbientLight(0x404040, 2); 
        scene.add(ambientLight);

        // 2. Key Light (Warm)
        const keyLight = new THREE.SpotLight(0xffeebb, 200);
        keyLight.position.set(10, 10, 10);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 1024;
        keyLight.shadow.mapSize.height = 1024;
        scene.add(keyLight);

        // 3. Fill Light (Cool)
        const fillLight = new THREE.PointLight(0x0044ff, 50);
        fillLight.position.set(-10, 0, 5);
        scene.add(fillLight);

        // 4. Rim Light (Bright, Sharp)
        const rimLight = new THREE.DirectionalLight(0xffffff, 4);
        rimLight.position.set(0, 5, -10);
        scene.add(rimLight);

        // --- Procedural Environment Map (PMREM) ---
        // We generate a simple cube render target to simulate a studio environment
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        
        // --- The Sphere Material (Custom Shader) ---
        // Complex shader for: Iridescence + Noise Normals + Veins + Fresnel
        const sphereGeometry = new THREE.IcosahedronGeometry(2, 60); // High detail

        const sphereMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x111111,
            metalness: 0.9,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            sheen: 1.0,
            sheenColor: 0x00ffff,
            transmission: 0, // Opaque metallic
            side: THREE.DoubleSide
        });

        // Inject custom shader logic via onBeforeCompile
        const noiseChunk = `
            // Simplex 3D Noise 
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; 
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z); 
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );  
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
        `;

        sphereMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = { value: 0 };
            shader.uniforms.uColor1 = { value: currentTheme.color1 };
            shader.uniforms.uColor2 = { value: currentTheme.color2 };
            shader.uniforms.uPulse = { value: 0 };

            shader.vertexShader = `
                uniform float uTime;
                uniform float uPulse;
                varying vec3 vPos;
                varying vec3 vNormalView;
                varying float vNoise;
                ${noiseChunk}
                ${shader.vertexShader}
            `.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                vPos = position;
                // Add subtle vertex displacement based on noise and pulse
                float n = snoise(position * 0.8 + uTime * 0.2);
                vNoise = n;
                float pulseDisplacement = uPulse * 0.2 * (n + 1.0);
                transformed += normal * pulseDisplacement;
                vNormalView = normalize(normalMatrix * normal);
                `
            );

            shader.fragmentShader = `
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform float uPulse;
                varying vec3 vPos;
                varying float vNoise;
                varying vec3 vNormalView;
                ${noiseChunk}
                ${shader.fragmentShader}
            `.replace(
                '#include <emissivemap_fragment>',
                `
                #include <emissivemap_fragment>
                
                // Procedural veins
                float veinNoise = snoise(vPos * 2.5 + uTime * 0.1);
                float veinMask = smoothstep(0.65, 0.7, abs(veinNoise)); // Create thin lines
                
                // Iridescence based on view angle (Fresnel-ish)
                vec3 viewDir = normalize(vViewPosition); // Assuming standard Three.js uniforms
                float fresnel = pow(1.0 - abs(dot(vNormalView, vec3(0.0, 0.0, 1.0))), 3.0);
                
                vec3 iridescentColor = mix(uColor1, uColor2, fresnel + vNoise * 0.2);
                
                // Emissive logic
                float emissionStrength = (1.0 - veinMask) * 2.0; // Glow in the veins
                emissionStrength += uPulse * 10.0 * (1.0 - veinMask); // Flash on pulse
                
                // Add base glow on hover
                emissionStrength += fresnel * 0.5;

                totalEmissiveRadiance += iridescentColor * emissionStrength;
                
                // Mix base color
                diffuseColor.rgb = mix(diffuseColor.rgb, iridescentColor, 0.2);
                `
            );
            
            // Store reference to update uniforms
            sphereMaterial.userData.shader = shader;
        };

        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        scene.add(sphere);

        // --- Post-Processing ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        composer.addPass(bloomPass);
        
        // Output pass handles tone mapping correctly for the final screen
        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // --- Interaction Handlers ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onTouchMove(event) {
            if (event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function triggerPulse() {
            if (CONFIG.reducedMotion) return;
            CONFIG.pulseIntensity = 1.0;
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('touchmove', onTouchMove, { passive: true });
        window.addEventListener('click', triggerPulse);
        window.addEventListener('touchstart', triggerPulse, { passive: true });
        
        // UI Controls
        const speedSlider = document.getElementById('speed-slider');
        speedSlider.addEventListener('input', (e) => CONFIG.rotationSpeed = parseFloat(e.target.value));

        const bloomToggle = document.getElementById('bloom-toggle');
        bloomToggle.addEventListener('change', (e) => {
            bloomPass.enabled = e.target.checked;
        });

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const colorKey = e.target.getAttribute('data-color');
                currentTheme = THEMES[colorKey];
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
            });
        });

        // Keyboard Accessibility
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                CONFIG.rotationSpeed = CONFIG.rotationSpeed > 0 ? 0 : 0.5;
            }
            if (e.code === 'KeyP') {
                const s = document.getElementById('stats-overlay');
                s.style.display = s.style.display === 'none' ? 'block' : 'none';
            }
            // Arrow keys for camera nudging done by OrbitControls naturally
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            stats.begin();

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // 1. Raycasting for Hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sphere);
            CONFIG.isHovered = intersects.length > 0;

            // 2. Update Shader Uniforms
            if (sphereMaterial.userData.shader) {
                const shader = sphereMaterial.userData.shader;
                shader.uniforms.uTime.value = elapsedTime;
                shader.uniforms.uColor1.value.lerp(currentTheme.color1, 0.05); // Smooth color transition
                shader.uniforms.uColor2.value.lerp(currentTheme.color2, 0.05);
                
                // Pulse Logic
                CONFIG.pulseIntensity *= CONFIG.pulseDecay;
                if(CONFIG.pulseIntensity < 0.01) CONFIG.pulseIntensity = 0;
                shader.uniforms.uPulse.value = CONFIG.pulseIntensity;
            }

            // 3. Rotation Physics
            // If hovered, slow down. If not, rotate at config speed.
            let targetRotSpeed = CONFIG.isHovered ? CONFIG.rotationSpeed * 0.1 : CONFIG.rotationSpeed;
            if (CONFIG.reducedMotion) targetRotSpeed = 0;
            
            sphere.rotation.y += targetRotSpeed * CONFIG.baseSpeed * 10;
            
            // Secondary wobble
            if (!CONFIG.reducedMotion) {
                sphere.rotation.z = Math.sin(elapsedTime * 0.5) * 0.05;
                sphere.rotation.x = Math.cos(elapsedTime * 0.3) * 0.05;
            }

            // 4. Update Bloom intensity based on hover/pulse
            if (bloomPass.enabled) {
                const targetStrength = CONFIG.isHovered ? 2.5 : 1.5;
                bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, targetStrength + CONFIG.pulseIntensity * 2, 0.1);
            }

            controls.update();
            
            // Render
            composer.render();
            stats.end();
        }

        // --- Initialization ---
        // Hide loader after a short delay to ensure shader compilation doesn't stutter visible frames
        setTimeout(() => {
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            animate();
        }, 1000);

    </script>
</body>
</html>